class Stack {
    constructor() {
        this.container = [];
        this.size = 0;
    }
    put(x) {
        if (Array.isArray(x)) {
            x.forEach(element => {
                this.container.push(element);
                this.size++;
            });
        } else {
            this.container.push(x);
            this.size++;
        } //O(1)
    }
    get() { // O( 1 )
        if (this.size) {
            this.size--;
            return this.container.pop(); // O( 1 )
        } else return null;
    }
    check() {
        return this.container[0]; // O( 1 )
    }
    toarray() { // O( n * get() )
            let rv = [];
            while (this.size) rv.push(this.get());
            return rv;
        }
        [Symbol.iterator]() { // O( n * get() )
            return {
                next: () => {
                    if (this.size > 0) {
                        return {
                            value: this.get(),
                            done: false
                        };
                    } else {
                        return {
                            done: true
                        };
                    }
                }
            };
        }
}
class Queue extends Stack {
    constructor() {
        super();
        this.offset = 0;
    }
    get() { // O( 1 )
        if (this.size) {
            this.size--;
            let elem = this.container[this.offset++];
            if (this.offset * 2 >= this.container.length) {
                this.container = this.container.slice(this.offset);
                this.offset = 0;
            }
            return elem; // O( 1 )
        } else return false;
    }
    check() {
        return this.container[this.offset]; // O( 1 )
    }
}
class PQueue extends Stack {
    constructor() {
        super();
    }
    comparator(a, b) {
            return b - a;
    }
    put(x) { // O(1) / element
        if (Array.isArray(x)) {
            x.forEach(element => {
                this.container.push(element);
                this.fix(this.size++);
            });
        } else {
            this.container.push(x);
            this.fix(this.size++);
        }
    }
    get() { // O(log n)
        if (this.size) {
            let ret = this.container[0];
            if (--this.size) {
                this.container[0] = this.container.pop();
                this.fixup(0);
            } else this.container.pop();
            return ret;
        } else return null;
    }
    fixup(p) { // O(log n)
        let q1 = ( p + 1 ) * 2 ,
        q2 = q1 - 1,
        q = 0;
        if (q1 > this.size + 2) q1 = p;
        if (q2 > this.size + 2) q2 = q1;
        if (this.container[q1] === undefined) q = q2;
        else if (this.container[q2] === undefined) q = q1;
        else {
            q = this.comparator(
                    this.container[q1],
                    this.container[q2]
                ) < 0 ? q1: q2;
        }
        if (p != q) {
            this.cshn(q, p);
            this.fixup(q);
        }
    }
    fix(p) { // O(log n)
        let q = Math.round( (p+1) / 2 - 0.4 ) - 1;
        this.cshn(p, q);
        if (q > 0) this.fix(q);
    }
    cshn(a, b) { // O(1)
        if ( this.container[a]==undefined ) return;
        if ( this.container[b] == undefined) return;
        if (this.comparator(
                this.container[a],
                this.container[b]
            ) < 0 )
            [ this.container[a], this.container[b] ] =
            [ this.container[b], this.container[a] ];
    }
}
class PQueue_min extends PQueue {
    comparator(a, b) {
        return a - b;
    }
    fixup(p) {
        let q1 = ( p + 1 ) * 2 ,
        q2 = q1 - 1,
        q = 0;
        if (q1 > this.size + 2) q1 = p;
        if (q2 > this.size + 2) q2 = q1;
        q = this.comparator(
            this.container[q1],
            this.container[q2]
        ) < 0 ? q1 : q2;
        if (p != q) {
            this.cshn(q, p);
            this.fixup(q);
        }
    }
}
module.exports = {
    Stack,
    Queue,
    PQueue,
    PQueue_min
};